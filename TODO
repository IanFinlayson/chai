Immediate:
    - add a // operator
    - bitwise mod assigns
    - list comprehensions
    - list slices
    - tuples
    - dicts
    - sets
    - come up with consistent erroring scheme, with line numbers
    - add error test cases, ensuring errors are produced for bad code

Re-think ranges:
    Do Haskell stype to allow a step and infinite ranges?
        [1,2..10] = [1,2,3,4,5,6,7,8,9,10]
        [1,3..10] = [1,3,5,7,9]
        [4,3..0]  = [4,3,2,1,0]
        [0,5..]   = [0,5,10,15,20,25,30,35...  -- infinite
        [1,1..]   = [1,1,1,1,1,1,1,1,1,1,1...  -- infinite
    Or math style [) (] type things?  Not sure about that
    Or just use the range function?
    Should produce generators eventually either way!

Things to add into language:
    - combine up def and match stmts??
    - generators, lazy sequences, yield, how to encode in type system?
        Idea: we use -> for normal function return
              and ->* or maybe >> for yield return types
    - classes or alternative...
    - libraries

Math stuff:
    - use bigints for integers like python?
    - separately, our ** always gives doubles (as java's math.pow), should we do ints?

Front End improvements:
    - allow line breaks in discriminated unions?
    - make long lines being joined with \ work
    - maybe steal python lexer...or write one by hand...

Roadmap:
    - write random code samples for each feature
    - write a tree-walking interpreter in Java, not
      efficient but easy to try things out in
    - write a more efficient compiler/VM backend

