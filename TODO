Lexer/parser:
    - lines ending with \
    - or lines ending with | for unions

    - get the traits implemented

    - test, test, test

    - think through the following language ideas:


Generators:
    - Add the yield keyword to lexer and parser
    - Allow for Int* to indicate a generator of Int in the type system
    - Change the list range syntax to be like Haskell:
        [1,2..10] = [1,2,3,4,5,6,7,8,9,10]
        [1,3..10] = [1,3,5,7,9]
        [4,3..0]  = [4,3,2,1,0]
        [0,5..]   = [0,5,10,15,20,25,30,35...  -- infinite
        [1,1..]   = [1,1,1,1,1,1,1,1,1,1,1...  -- infinite

Traits:
    - add trait stuff into the parser, including the implement block
    - can we make the implement block add methods to a type separate from any trait?
      like we could add our own methods to String or List....
    - think through the traits built into the language:
        - like Show, Ord, etc. type classes in Haskell
        - maybe Generator is a trait so people can make classes that are generators
        - also callable, addable, etc. are traits??? not sure - this can provide operator overloading essentially




Things to add into language:
    - combine up def and match stmts??
    - libraries and modules
    - multiple fors in list comprehension (like python)?


